#!/usr/bin/env python3
# Merge results from nested JSON evaluations files.
import os
import json

XGBOOST_PARAMS_SORT_ORDER = [
    "name",
    "booster",
    "learning_rate",
    "min_split_loss",
    "max_depth",
    "min_child_weight",
    "max_delta_step",
    "subsample",
    "sampling_method",
    "reg_lambda",
    "reg_alpha",
    "tree_method",
    "process_type",
    "grow_policy",
    "max_leaves",
    "predictor",
    "num_parallel_tree",
    "objective",
    "num_class",
    "eval_metric",
    "seed",
]


def write_readme(fpath: str, evaluations: list) -> None:
    with open(fpath, "w") as f:
        f.write("\n".join([
            "# XGBoost Summary",
            "",
            "This file was autogenerated by `aggregate_results.py` -- do not change it manually.  ",
            "",
            "<table>",
            "    <tr>",
            "        <th>Accuracy</th>",
            "        <th>Parameters</th>",
            "    </tr>",
        ]))
        f.write("\n")

        def nice_dict(d: dict) -> str:
            legal_params = set(XGBOOST_PARAMS_SORT_ORDER)
            d_params = set(d.keys())
            assert legal_params >= d_params, f"bad param (missing XGBOOST_PARAMS_SORT_ORDER entry?): {d_params - legal_params}"

            return "\n".join([
                "{:<20}: {},".format(f'"{k}"', repr(d[k]).replace("'", '"'))
                for k in XGBOOST_PARAMS_SORT_ORDER if k in d
            ])

        evaluations.sort(key=lambda x: x["accuracy"], reverse=True)
        for e in evaluations:
            f.write("\n".join([
                "    <tr>",
                "        <td style=\"text-align: center\">{}</td>".format(e["accuracy"]),
                "        <td>",
                "            <pre>",
                "                <code>",
                e["name"],
                nice_dict(e["parameters"]),
                "                </code>",
                "            </pre>",
                "        </td>",
                "    </tr>",
            ]))
            f.write("\n")
        f.write("</table>\n")


if __name__ == "__main__":
    data: dict[str, dict] = {}

    def recurse(dir: str = ".", parent: str = ""):
        for fname in os.listdir(dir):
            fpath = os.path.join(dir, fname)
            if os.path.isdir(fpath):
                recurse(fpath, dir)
            elif os.path.isfile(fpath):
                if fname == "evaluations.json":
                    with open(fpath) as f:
                        d = json.load(f)
                    dirname = os.path.basename(dir)
                    assert dirname not in data
                    data[dirname] = d

    recurse()
    squashed_data = []
    for name, evaluations in data.items():
        for run in evaluations["runs"]:
            run["name"] = name  # bit of a dirty hack, but works
            squashed_data.append(run)

    with open("all_evaluations.json", "w") as f:
        json.dump(squashed_data, f, indent=4)
    write_readme("README.MD", squashed_data)
